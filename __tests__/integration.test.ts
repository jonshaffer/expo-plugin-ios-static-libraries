import * as fs from 'fs';
import path from 'path';

// Mock the entire @expo/config-plugins module
jest.mock('@expo/config-plugins', () => {
  return {
    withDangerousMod: jest.fn((config, [platform, modFn]) => {
      return {
        _mock_mod_fn: modFn
      };
    })
  };
});

// Mock the fs module
jest.mock('fs', () => {
  return {
    ...jest.requireActual('fs'),
    existsSync: jest.fn(),
    readFileSync: jest.fn(),
    writeFileSync: jest.fn(),
  };
});

describe('Integration tests with realistic Podfiles', () => {
  let withIosStaticLibraries: any;
  
  // Before each test, re-import the module to get a fresh instance with clean mocks
  beforeEach(() => {
    jest.clearAllMocks();
    
    // We need to re-import the module to get the newly mocked version
    jest.isolateModules(() => {
      withIosStaticLibraries = require('../index').default;
    });
  });

  const runModFunction = async (config: any, libraries: string[], podfileContent: string) => {
    // Setup existsSync and readFileSync mocks
    (fs.existsSync as jest.Mock).mockReturnValue(true);
    (fs.readFileSync as jest.Mock).mockReturnValue(podfileContent);
    
    // Call the plugin
    const result = withIosStaticLibraries(config, { libraries });
    
    // Get the mod function
    const modFn = result._mock_mod_fn;
    
    // Run the mod function
    await modFn(config);
    
    // Check if writeFileSync was called
    const wasPodfileWritten = (fs.writeFileSync as jest.Mock).mock.calls.length > 0;
    
    // Get the content that was written, if any
    const writtenContent = wasPodfileWritten 
      ? (fs.writeFileSync as jest.Mock).mock.calls[0][1] 
      : '';
    
    return {
      writtenContent,
      wasPodfileWritten
    };
  };

  it('should work with a real-world Expo/React Native Podfile', async () => {
    const mockConfig = {
      modRequest: {
        platformProjectRoot: '/mock/path'
      }
    };
    
    // A realistic Podfile generated by React Native / Expo
    const realisticPodfile = `
require_relative '../node_modules/react-native/scripts/react_native_pods'
require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules'
require_relative '../node_modules/react-native-unimodules/cocoapods.rb'

platform :ios, '13.0'

target 'ExpoApp' do
  use_unimodules!
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => true,
    :fabric_enabled => false,
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  # Uncomment to opt-in to using Flipper
  #
  # Note that if you have use_frameworks! enabled, Flipper will not work
  #
  # use_flipper!()

  post_install do |installer|
    react_native_post_install(installer)
    __apply_Xcode_12_5_M1_post_install_workaround(installer)

    # Workaround for https://github.com/facebook/react-native/issues/31163
    # Temporary fix for iOS 15 CoreAnimations crash
    installer.pods_project.targets.each do |target|
      target.build_configurations.each do |config|
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0'
        config.build_settings["EXCLUDED_ARCHS[sdk=iphonesimulator*]"] = "arm64"
      end
    end
  end
end

target 'OneSignalNotificationServiceExtension' do
  pod 'OneSignalXCFramework', '>= 5.0.0', '< 6.0'
end
`;

    const libraries = ['react-native-fbsdk-next', 'OneSignalXCFramework', 'react-native-google-maps'];

    const { writtenContent } = await runModFunction(mockConfig, libraries, realisticPodfile);
    
    // Check that we preserve all the important original content
    expect(writtenContent).toContain('require_relative \'../node_modules/react-native/scripts/react_native_pods\'');
    expect(writtenContent).toContain('target \'ExpoApp\' do');
    expect(writtenContent).toContain('target \'OneSignalNotificationServiceExtension\' do');
    expect(writtenContent).toContain('post_install do |installer|');
    expect(writtenContent).toContain('__apply_Xcode_12_5_M1_post_install_workaround(installer)');
    
    // Check that our pre_install block exists and has the right libraries
    expect(writtenContent).toContain('pre_install do |installer|');
    expect(writtenContent).toContain('pod.name.eql?(\'react-native-fbsdk-next\')');
    expect(writtenContent).toContain('pod.name.eql?(\'OneSignalXCFramework\')');
    expect(writtenContent).toContain('pod.name.eql?(\'react-native-google-maps\')');
    expect(writtenContent).toContain('Pod::BuildType.static_library');
    
    // Make sure we haven't duplicated any important blocks
    const postInstallMatches = (writtenContent.match(/post_install do \|installer\|/g) || []).length;
    expect(postInstallMatches).toBe(1);
    const preInstallMatches = (writtenContent.match(/pre_install do \|installer\|/g) || []).length;
    expect(preInstallMatches).toBe(1);
  });

  it('should handle Podfile with existing static library configuration', async () => {
    const mockConfig = {
      modRequest: {
        platformProjectRoot: '/mock/path'
      }
    };
    
    // Podfile that already has some static library configuration
    const podfileWithExistingStaticLibs = `
require_relative '../node_modules/react-native/scripts/react_native_pods'
require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules'

platform :ios, '13.0'

target 'MyApp' do
  config = use_native_modules!
  use_react_native!(:path => config[:reactNativePath])
  
  # Specific pods
  pod 'Firebase', :modular_headers => true
  pod 'GoogleUtilities', :modular_headers => true
end

pre_install do |installer|
  # Existing static library configuration
  installer.pod_targets.each do |pod|
    if pod.name.eql?('ExistingStaticLib') || pod.name.eql?('AnotherExistingLib')
      def pod.build_type
        Pod::BuildType.static_library
      end
    end
  end
end
`;

    const libraries = ['NewStaticLib', 'OneMoreLib'];

    const { writtenContent } = await runModFunction(mockConfig, libraries, podfileWithExistingStaticLibs);
    
    // Check that our original static lib configuration is preserved
    expect(writtenContent).toContain("if pod.name.eql?('ExistingStaticLib') || pod.name.eql?('AnotherExistingLib')");
    
    // Check that our new libraries are added and properly inserted
    expect(writtenContent).toContain("# Added by expo-plugin-ios-static-libraries");
    expect(writtenContent).toContain("pod.name.eql?('NewStaticLib') || pod.name.eql?('OneMoreLib')");
    
    // Make sure we're not creating a duplicate pre_install block
    const preInstallMatches = (writtenContent.match(/pre_install do \|installer\|/g) || []).length;
    expect(preInstallMatches).toBe(1);
    
    // The original static library code and our new code should both be in the pre_install block
    expect(writtenContent).toContain('ExistingStaticLib');
    expect(writtenContent).toContain('AnotherExistingLib');
    expect(writtenContent).toContain('NewStaticLib');
    expect(writtenContent).toContain('OneMoreLib');
  });
});